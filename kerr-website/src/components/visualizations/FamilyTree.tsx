'use client';\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport * as d3 from 'd3';\n\n// Types\ninterface Person {\n  id: string;\n  firstName: string;\n  lastName: string;\n  middleName?: string;\n  birthDate?: string;\n  deathDate?: string;\n  relationships?: Relationship[];\n  branch?: string;\n  generation?: number;\n}\n\ninterface Relationship {\n  type: string;\n  personId: string;\n  years?: string;\n}\n\ninterface FamilyTreeNode extends d3.HierarchyNode<Person> {\n  x: number;\n  y: number;\n  data: Person;\n}\n\ninterface FamilyTreeProps {\n  data: Person[];\n  rootPersonId: string;\n  width: number;\n  height: number;\n  onPersonSelect?: (person: Person) => void;\n  className?: string;\n}\n\nexport default function FamilyTree({\n  data,\n  rootPersonId,\n  width,\n  height,\n  onPersonSelect,\n  className = ''\n}: FamilyTreeProps) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [selectedPerson, setSelectedPerson] = useState<string | null>(rootPersonId);\n  \n  // Process data into hierarchy\n  const processData = (people: Person[], rootId: string) => {\n    // Find the root person\n    const root = people.find(p => p.id === rootId);\n    if (!root) return null;\n    \n    // Create a map of people by id for easy lookup\n    const peopleMap = new Map<string, Person>();\n    people.forEach(person => peopleMap.set(person.id, person));\n    \n    // Helper function to create a hierarchical structure\n    const buildHierarchy = (person: Person, depth = 0): any => {\n      if (depth > 3) return null; // Limit depth to prevent infinite recursion\n      \n      const children: any[] = [];\n      \n      // Add children\n      const childRelationships = person.relationships?.filter(r => r.type === 'child') || [];\n      childRelationships.forEach(rel => {\n        const child = peopleMap.get(rel.personId);\n        if (child) {\n          // Only process each person once\n          children.push(buildHierarchy(child, depth + 1));\n        }\n      });\n      \n      // Return the node with children\n      return {\n        ...person,\n        children: children.length > 0 ? children : null\n      };\n    };\n    \n    return buildHierarchy(root);\n  };\n\n  useEffect(() => {\n    if (!svgRef.current || !data || data.length === 0) return;\n    \n    // Clear previous rendering\n    d3.select(svgRef.current).selectAll('*').remove();\n    \n    // Process data into hierarchy\n    const hierarchyData = processData(data, rootPersonId);\n    if (!hierarchyData) return;\n    \n    // Create the hierarchy\n    const root = d3.hierarchy(hierarchyData);\n    \n    // Create the tree layout\n    const treeLayout = d3.tree<Person>()\n      .size([width - 100, height - 100]);\n    \n    // Apply the layout to the hierarchy\n    const rootNode = treeLayout(root) as FamilyTreeNode;\n    \n    // Create the svg group and apply a transformation\n    const svg = d3.select(svgRef.current);\n    const g = svg.append('g')\n      .attr('transform', `translate(50, 50)`);\n    \n    // Add zoom and pan behavior\n    const zoom = d3.zoom<SVGSVGElement, unknown>()\n      .scaleExtent([0.1, 3])\n      .on('zoom', (event) => {\n        g.attr('transform', event.transform);\n      });\n    \n    svg.call(zoom);\n    \n    // Extract nodes and links\n    const nodes = rootNode.descendants();\n    const links = rootNode.links();\n    \n    // Create links\n    g.selectAll('.link')\n      .data(links)\n      .enter()\n      .append('path')\n      .attr('class', 'family-tree-link')\n      .attr('d', d3.linkHorizontal<any, any>()\n        .x(d => d.y)\n        .y(d => d.x)\n      );\n    \n    // Create nodes\n    const nodeGroups = g.selectAll('.node')\n      .data(nodes)\n      .enter()\n      .append('g')\n      .attr('class', 'family-tree-node')\n      .attr('transform', d => `translate(${d.y}, ${d.x})`)\n      .on('click', (event, d) => {\n        setSelectedPerson(d.data.id);\n        if (onPersonSelect) {\n          onPersonSelect(d.data);\n        }\n      });\n    \n    // Add node circles\n    nodeGroups.append('circle')\n      .attr('r', 25)\n      .attr('fill', d => {\n        // Color based on branch or generation\n        if (d.data.branch === 'paternal') return '#2563eb'; // blue\n        if (d.data.branch === 'maternal') return '#db2777'; // pink\n        if (d.data.branch === 'core') return '#059669'; // green\n        if (d.data.branch === 'california') return '#ca8a04'; // yellow\n        if (d.data.branch === 'louisiana') return '#7c3aed'; // purple\n        return '#6b7280'; // gray default\n      })\n      .attr('class', d => d.data.id === selectedPerson ? 'family-tree-node-selected' : '');\n    \n    // Add text labels\n    nodeGroups.append('text')\n      .attr('dy', 40)\n      .attr('text-anchor', 'middle')\n      .attr('class', 'text-sm font-medium')\n      .text(d => `${d.data.firstName} ${d.data.lastName}`);\n    \n    // Add birth/death years if available\n    nodeGroups.append('text')\n      .attr('dy', 55)\n      .attr('text-anchor', 'middle')\n      .attr('class', 'text-xs text-slate-600')\n      .text(d => {\n        if (d.data.birthDate && d.data.deathDate) {\n          return `${d.data.birthDate.split(' ')[0]} - ${d.data.deathDate.split(' ')[0]}`;\n        }\n        if (d.data.birthDate) {\n          return `b. ${d.data.birthDate.split(' ')[0]}`;\n        }\n        if (d.data.deathDate) {\n          return `d. ${d.data.deathDate.split(' ')[0]}`;\n        }\n        return '';\n      });\n    \n  }, [data, rootPersonId, width, height, selectedPerson, onPersonSelect]);\n\n  return (\n    <div className={`family-tree-container relative ${className}`}>\n      <svg \n        ref={svgRef} \n        width={width} \n        height={height} \n        className=\"bg-white rounded-lg shadow\"\n      ></svg>\n    </div>\n  );\n}